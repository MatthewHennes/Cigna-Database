My Design:
  I chose to represent PolicyHolders, Doctors, and Hospitals each as their own class.
    Each of these three classes contains a List of the other two which are associated to it. For example, the PolicyHolder class contains a List of Doctors and a List of Hospitals. I chose this method because any individual PolicyHolder may visit multiple doctors at multiple hospitals. Likewise, a doctor will almost certainly have multiple patients (PolicyHolders), and could potentially work at multiple hospitals. Finally, a hospital would certianly be expected to have multiple doctors as well as multiple patients.
    Each of theses classes (PolicyHolders, Doctors, and Hospitals) also have a name associated with them. While in a full implementation, there would most likely be more relevant information to any given item (PolicyHolder, Doctor, or Hospital), this name serves as a representation of how these other pieces of information could be easily implemented.
    For each list contained in a PolicyHolder, Doctor, or Hospital, there is a function to get a copy of that list.
    There is also a function to get the name of any PolicyHolder, Doctor, or Hospital.
    Finally, each of these classes (PolicyHolder, Doctor, and Hospital) all contain functions to add elements to their lists (PolicyHolder has functions to add Doctors and Hospitals to their respective Lists, Doctor has functions to add PolicyHolders and Hospitals to their repective Lists, and Hospital has functions to add PolicyHolders and Doctors to their respective Lists).
  In order to facilitate making connections between two things, I created a static LinkCreator class. This class simply contains functions to create links between any two combinations of items. Each of these functions simply adds the two items passed to it the the other one's list. For example, the createLink(PolicyHolder, Doctor) function adds the given PolicyHolder to the given Doctor's list of PolicyHolders, and the given Doctor to the given PolicyHolder's list of Doctors. This is accomplished using the add functions in each class.
Alternative Designs:
  One alternative design would be to have one "Node" class, and to have PolicyHolder, Doctor, and Hospital all be subclasses of that Node class. The Node class would then maintain a list of other nodes that were linked to it. I chose not to use this design, however, because I wanted to specifically choose which classes could be associated to which others. For example, perhaps in the future it would be desireable to add a CignaRepresentative class to represent a PolicyHolder's representative at Cigna in order to keep track of sales, commission, or other information. In that case, it should be possible to link CingaRepresentatives to PolicyHolders, but it would be undesirable for that same CingaRepresentative to be able to link to Hospitals (here I make the assumption that the same people do not sell insurance individuals and make agreements with hospitals). Essentially, I wanted to maintain the explicitness of which types of users can have links to which others.
  Another alternative design would be to to have separate classes for PolicyHolders, Doctors, and Hospitals as I have now, but to maintain one large list of links rather than having each Object maintain its own lists. I chose not to use this design because that design would make it difficult to find the things linked to one specific object. For example, if a person wanted to find all the patients that are linked to a certain hospital, it would be necessary to search the entire list of links for all links between that individual hospital and any PolicyHolder. This would make these types of searches perform slowly and be somewhat less convenient to implement.
  An additional alternative design would be to to have the Hospital class maintain a list of Doctors, and the Doctor class maintain a list of patients. This design would allow for fast searches and simple implementation, but would break down if any PolicyHolder had multiple Doctors, as many people do, or if any Doctor worked at multiple hospitals (as I imagine some, especially specialists, probably do). This would also impose the limitation that a Hospital's only patients would be those inherited through its Doctors. In real life, however, a Hospital may have patients not associated with one specific doctor (in the emergency room, for example).
Advantages of my Design:
  My design allows for a very wide variety of supported links (any class can be easily linked to any other), but maintains the full ability to limit what classes can link to which other ones (only links that are specifically supported can be made).
  My design could potentially have extremely fast searches. If a person wanted all of the PolicyHolders associated with any specific Hospital, they need only call that Hospital's getPolicyHolders() function. As currently implemented, these get functions return copies of the list (in order to ensure that no outside sources have references to the original lists, and thereby change those lists). Because of this copy, searches are currently O(n) where n is the number of items being returned. If it was acceptable to return references to the original lists, however, searches could be made O(1), or essentially instantaneous. I believe that this fast and easy searching functionality would be highly advantageous for your database because it could be used to provide useful information to your clients. For example, if a Hospital notices that they are losing a lot of patients, they could easily search for what hositals those patients are now using, and thereby gain a sense of what they need to do better in order to keep their patient base. These analysis abilities could be a headlining advantage of your company over other insurance providers.
Drawbacks of my Design:
  One drawback of my design is that it is relatively slow to add links. Because each link created actually requires two items to be added to separate lists, each link added will take slightly longer in my design than in some other possible designs. I feel this is acceptable, however, because in exchange for a slight performance drop in add calls, we gain a large performance boost in searches in comparison to other designs. While the add functions in my design are slightly slower than they could be in other designs, they are still O(n), so I feel the performance drop is not unacceptable.
  Because each item maintains its own lists of links, my design uses double the memory that would be minimally necessary to represent links. I think this is acceptable for two reasons. First, by having links stored in both locations (each of the two items being linked), it would be possible to re-build links upon some type of data loss. If, for example, all of the links to a hospital were lost, they could be re-built by checking each PolicyHolder and Doctor for links to that Hospital, and then re-adding links from the Hospital to the PolicyHolder or Doctor. While this process would be slow, it is always advantageous to have some method of data recovery in case of an emergency. Second, by maintaining lists in two locations, we can make extremely fast searches. Searches using another design would have to access far mor memory locations, and therefore would be much slower, unless the memory was much faster. Because it is generally much cheaper to purchase more memory rather than faster memory, I feel my design is much more cost effective in order to achieve resonably fast searches.
Important things to add to this design:
  One very important ability that I have not implemented in my code is the ability to remove links. This could easily be implemented as the reverse of the addLink() functions (removing items from lists rather than adding them). These removes would have the same performance as the adds.